/*--------------------------------*- C++ -*----------------------------------*\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     | Version:  v2012                                 |
|   \\  /    A nd           | Website:  www.openfoam.com                      |
|    \\/     M anipulation  |                                                 |
\*---------------------------------------------------------------------------*/
FoamFile
{
    version     2.0;
    format      ascii;
    class       dictionary;
    object      fvOptions;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

codedSource
{
    type            vectorCodedSource;
    name            USrc;
    active          true;

    selectionMode   all;
    fields          (U);

    xmax           0.06;
    ymax           0.06;
    xmin           0.02;
    ymin           0.02;
    box ($xmin $ymin -1) ($xmax $ymax 1);
    Sv  1e-3;

    codeInclude
    #{
        #include "cellSet.H"
        #include "boxToCell.H"
        #include "processorFvPatch.H"
        #include "meshTools.H"
        #include "syncTools.H"
    #};

    codeCorrect
    #{
    #};

    codeConstrain
    #{
    #};

    codeAddSup
    #{
        Info<< "Executing codeAddSup" << endl;

        // Coefficients field
        autoPtr<volScalarField> kPtr;
        if (!Pstream::parRun()) {
            kPtr.reset
            (
                new volScalarField
                (
                    IOobject
                    (
                        "k",
                        Foam::name(mesh().time().startTime().value()),
                        mesh(),
                        IOobject::NO_READ,
                        IOobject::NO_WRITE,
                        false
                    ),
                    mesh(),
                    dimensionedScalar("z", dimless, 0)
                )
            );
        } else {
            kPtr.reset
            (
                new volScalarField
                (
                    IOobject
                    (
                        "k",
                        Foam::name(mesh().time().startTime().value()),
                        mesh(),
                        IOobject::MUST_READ,
                        IOobject::NO_WRITE,
                        false
                    ),
                    mesh()
                )
            );
        }
        volScalarField&  k = kPtr();

        // Total source value
        scalar Sv = readScalar(coeffs_.lookup("Sv"));

        // Setup the box and select cells
        //const word boxString = "(0.02 0.025 -1) (0.04 0.035 1)";
        boxToCell box(mesh(), coeffs_.lookup("box"));
        cellSet boxCells(mesh(), "boxCells", IOobject::NO_READ);
        box.applyToSet(topoSetSource::setAction::NEW, boxCells);

        // Randomize k if running in serial
        if (!Pstream::parRun()) {
            Random rd(1234);
            for(auto& c: boxCells) {
                k[c] = rd.sample01<scalar>();
            }
        }

        // Apply source to the selected cells
        vectorField& USource = eqn.source();
        labelList  nNeis(mesh().nCells(), 1);
        for(auto& c : boxCells) {
            scalar kAvg = k[c];
            // Loop through neighbours of cell c, to get an average value for k
            for(auto& e : mesh().cellCells()[c]){
                // Use the cell set to only include cells inside the box
                if (boxCells.find(e) != boxCells.end())
                {
                    kAvg += k[e];
                    nNeis[c] += 1;
                }
            }
            USource[c] = vector(Sv*kAvg, 0, 0);
        }

        if (Pstream::parRun())
        {
            // A list of scalars to hold copies of K values at all boundary cells
            // for current MPI rank
            scalarList kAtBoundary(mesh().nBoundaryFaces(), 0);
            // A boolean list to see if the corresponding boundary cell is inside the source box
            boolList bCellIsInBox(mesh().nBoundaryFaces(), false);
            // populate kAtBoundary and bCellInBox with correct values
            forAll(kAtBoundary, i)
            {
                auto patch = mesh().boundaryMesh().whichPatch(i+mesh().nInternalFaces());
                auto facei = i + mesh().nInternalFaces() - mesh().boundary()[patch].start();
                auto bCell = mesh().faceOwner()[i+mesh().nInternalFaces()];
                kAtBoundary[i] = k[bCell];
                bCellIsInBox[i] = boxCells.find(bCell) != boxCells.end();
            }
            // Swap boundary lists between processor-to-processor interfaces
            syncTools::swapBoundaryFaceList(mesh(), kAtBoundary);
            syncTools::swapBoundaryFaceList(mesh(), bCellIsInBox);
            // Loop through processor faces, add source term if the swapped value was on
            // a cell inside the source box on the other side of the processor interface
            forAll(kAtBoundary, i)
            {
                label bCell = mesh().faceOwner()[i+mesh().nInternalFaces()];
                auto patch = mesh().boundaryMesh().whichPatch(i+mesh().nInternalFaces());
                auto patchPtr = dynamic_cast<const processorPolyPatch*>(&mesh().boundaryMesh()[patch]);
                if (bCellIsInBox[i] && patchPtr)
                {
                    // update source term
                    USource[bCell] += vector(Sv*kAtBoundary[i], 0, 0);
                    // update number of neighbours
                    nNeis[bCell] += 1;
                }
            }
        }
        for(auto& c : boxCells) {
            USource[c] /= nNeis[c];
        }
        if (mesh().time().writeTime()) k.write();
    #};
}

//
// ************************************************************************* //
